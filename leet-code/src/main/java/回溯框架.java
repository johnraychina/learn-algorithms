/**
 * 全排列问题 N皇后问题
 *
 * @author Zhang Yi
 */
public class 回溯框架 {

    //路径: 前面已经做出的选择
    //选择列表：当前还能做出的选择
    //结束条件：达到决策树的底层，无法再做选择的条件。
    //void backtrack(int[] nums, int start) {
    //    if (达到结束条件) {
    //        result.add(路径)
    //        return;
    //    }
    //
    //    for 选择 in 选择列表
    //        做选择;
    //        backtrack(路径, 选择列表);
    //        撤销选择;
    //    }
    //}
    /*
     * 其实想想看，回溯算法和动态规划是不是有点像呢？
     * 我们在动态规划系列文章中多次强调，
     * 动态规划的三个需要明确的点就是「状态」「选择」和「base case」，
     * 是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？
     * <p>
     * 某种程度上说，动态规划的暴力求解阶段就是回溯算法。
     * 只是有的问题具有重叠子问题性质，可以用 dp table
     * 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。
     *
     * 而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。
     */

}
