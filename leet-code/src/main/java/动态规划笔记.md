
# 动态规划介绍
- Components for general DP model:
    - Optimization/target function f(x) on set S;
    - A recurrence relation for the function f(x);
    - The recurrence relation introduces a DAG on S.
    
- Counter-example
    - Note: f(x) = min{f(x-1), f(x+1)} for x={0,1,...n-1} is not a valid recurrence relation for dynamic programming
- Example
    - problem: Russion-Doll-Envelopes.
    - extension: What if rotation is allowable?
    What if the dimension is larger than two?


# 动态规划问题求解过程
识别整体问题、变量、约束
- 定义子问题：有多少个子问题
- 猜想子问题的选择：一个子问题有多少个选择
- 子问题解法：每个子问题的计算时间
- 递归 + 记忆: 构建【状态转移方程】：通过递归或者自底向上构建中间结果dp table。
需要注意的是：需要保证子问题之间无循环依赖DAG，即保证拓扑顺序
- （结合所有子问题）解决整体问题

# 分类：
- 1-D
    - 位置/长度递推：LCS, LIS, Maximize profit with at most k stock transactions
    - 区间递推: Longest palindromic subsequence
- 2-D
    - Minimum path sum
- On values
    - 找零问题：Coin change
    - 背包问题: Backpack I and Backpack II
- On DAGs or Trees
    - DAG递推：Russion doll envelopes
    - Tree递推：Binary tree cameras
- 博弈论
    - 状态转换形成DAG： Stone game, Tic-Tac-Toe
    - 状态转换（未形成DAG）：中国象棋（开局or残局）


# 动态规划模板

```Java
//初始化 base case
dp[0][0][...] = base

//状态遍历
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            //状态转移（递推）
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)

return dp[n][n];
```

# 常见问题的状态定义

1. Sequence problems：prefix/postfix/interval/length

Longest increasing sequence:   
    LIS[i] = longest increasing sequence end with A[i]

Longest common sequence:   
    LCS[i][j] = longest common sequence between sequences: {A[0]...A[i]} and {B[0]..B[j]}

Longest palindromic sequence:
    LPS[i][j] = longest palindromic sequence of s.substring(i, j)

Maximize profit with at most k stock transactions
    dp[i][k][s] = max profits at days [0, i] with buy status s=[buy, sell] with at most k transactions

2. Grids or matrices problems
Minimum path sum:
    dp[i][j] = minimum path sum at location(i, j)

Maximal square:

Maximum students taking exam, Maximal rectangle

Cherry pickup, Cherry pickup II


3. On values
找零问题：Coin change
背包问题: Backpack I and Backpack II
dp[c][i] = largest value within capacity c, and item number i.

