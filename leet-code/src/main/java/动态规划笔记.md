
# 动态规划介绍
- Components for general DP model:
    - Target function f(x) on set S;
    - A recurrence relation for the function f(x);
    - The recurrence relation introduces a DAG on S.
    
- Counter-example
    - Note: f(x) = min{f(x-1), f(x+1)} for x={0,1,...n-1} is not a valid recurrence relation for dynamic programming
- Example
    - problem: Russion-Doll-Envelopes.
    - extension: What if rotation is allowable?
    What if the dimension is larger than two?

# 动态规划常见问题类型
- 1-D
    - 位置/长度递推：LCS, LIS, Maximize profit with at most k stock transactions
    - 区间递推: Longest palindromic subsequence
- 2-D
    - Minimum path sum
- On values
    - 找零问题：Coin change
    - 背包问题: Backpack I and Backpack II
- On DAGs or Trees
    - DAG递推：Russion doll envelopes
    - Tree递推：Binary tree cameras
- Game theory 博弈论
    - 状态转换形成DAG： Stone game, Tic-Tac-Toe
    - 状态转换（未形成DAG）：中国象棋（开局or残局）


# 动态规划模板

```Java
//初始化 base case
dp[0][0][...] = base

//状态遍历
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            //状态转移（递推）
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)

return dp[n][n];
```

# 常见问题的状态定义

1. Sequence problems：prefix/postfix/interval/length

Longest increasing sequence:   
    LIS[i] = longest increasing sequence end with A[i]

Longest common sequence:   
    LCS[i][j] = longest common sequence between sequences: {A[0]...A[i]} and {B[0]..B[j]}

Longest palindromic sequence:
    LPS[i][j] = longest palindromic sequence of s.substring(i, j)

Maximize profit with at most k stock transactions
    dp[i][k][s] = max profits at days [0, i] with buy status s=[buy, sell] with at most k transactions

2. Grids or matrices problems
Minimum path sum:
    dp[i][j] = minimum path sum at location(i, j)

Maximal square:

Maximum students taking exam, Maximal rectangle

Cherry pickup, Cherry pickup II


3. On values
找零问题：Coin change
背包问题: Backpack I and Backpack II
dp[c][i] = largest value within capacity c, and item number i.

4. On DAGs or Trees

- DP on DAGs: Russian doll envelops
- DP on Trees: Longest zigzag path in a binary tree
    - Target function: dp[node][dir] = The longest zigzag path starting from node with direction dir(left/right).
    - Recurrence relation: 
    dp[node][left] = dp[node->left][right] + 1
    dp[node][right] = dp[node->right][left] + 1
    - Solution: Maximal value for all possible dp[node][dir]
    - Note: No memorization is required in DFS since no node will be visited twice.
    - Note: Some dynamic programming on trees can be replaced by greedy algorithm from leaf.
    For example, the problem: Binary tree cameras.
- Longest string chain
- Binary tree cameras
- Maximum BST in binary tree

5. Game theory problems 博弈论
- Stone game II
- Dynamic programming algorithm
    - target function: dp[i][m] = 

- General Model: Minmax rule for the loss(e.g. maximize the minimal gain for the example problem)

6. Single source shortest path
- BFS: 可以有环
- DP: DAG
- Dijkstra: construct shortest paths greedily
- Bellman-Ford: Add the length dimension to make dynamic programming feasible:
e.g. Cheapest flights within K stops 

# 小结：
## top down: DFS + memorization
f(x):
    f(n) = f(n-1) + f(n-2)

- valid states or inital state hard to be determined before traversal(隐式图)
- state transition is more natural from top to down.
Example: Longest increasing path in a matrix
Example: The best strategy of Tic-Tac-Toe(五子棋)


## bottom up: construction
for n in [...]
    f(n) = f(n-1) + f(n-2)

- simple and easy to debug 

## optimization
- Space optimization: Rolling on the array
    - Example: Longest Common subsequence
    - Example: Minimum number of refueling stops
    - Other: Edit distance, Maximal square, Mininum path sum

- Time optimization: compute the recurrence relation transfer.
    - Example: Constrained subsequence sum
        - Note: let dp[i] =  the largest sum of constrained subsequences ending at i
        - Note: since dp[i] = max{ dp[i-1]...dp[i-k]} + nums[i],
        a sliding window maximum algorithm(with dequeue or heap) can help for improving the performance
    - Example: Maxmimum profit in job scheduling
    - Example: 四边形不等式优化
        - type one: Paper by F.Yao
        - type two: Paper by D.Eppstein
    

