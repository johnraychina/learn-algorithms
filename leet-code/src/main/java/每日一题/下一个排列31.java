package 每日一题;

/**
 * <pre>
 * 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
 *
 * 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
 *
 * 必须 原地 修改，只允许使用额外常数空间。
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/next-permutation
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 *
 * 输入：nums = [1,2,3]
 * 输出：[1,3,2]
 *
 * 输入：[1,3,2]
 * 输出：[3,1,2]
 *
 *
 * 输入：nums = [3,2,1]
 * 输出：[1,2,3]
 * </pre>
 */
public class 下一个排列31 {

    public void nextPermutation(int[] nums) {

        //所有排列形成一棵树，回溯算法可以遍历
        //每个叶子节点就是一个排列
        //遍历路径可以排序，按照一定遍历顺序可以找到下一个更大排列
    }
}
